package main

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"

	"github.com/gorilla/mux"
	"github.com/imrushi/oauth2-openid-hydra/pkg/tracer"
	negronilogrus "github.com/meatballhat/negroni-logrus"
	"github.com/opentracing/opentracing-go"
	"github.com/pkg/errors"
	"github.com/urfave/negroni"
	"golang.org/x/oauth2"
)

// Endpoint is OAuth 2.0 endpoint.
var Endpoint = oauth2.Endpoint{
	AuthURL:  "http://localhost:4444/oauth2/auth",
	TokenURL: "http://localhost:4444/oauth2/token",
}

// Scopes: OAuth 2.0 scopes provide a way to limit the amount of access that is granted to an access token.
var OAuthConf = &oauth2.Config{
	RedirectURL:  os.Getenv("REDIRECT_URL"),
	ClientID:     os.Getenv("CLIENT_ID"),
	ClientSecret: os.Getenv("CLIENT_SECRET"),
	// offline scope for requesting Refresh Token
	// openid for Open ID Connect
	Scopes:   []string{"name", "email", "offline", "openid"},
	Endpoint: Endpoint,
}

var stateStore = map[string]bool{}

func main() {
	// Prepare Opentracing
	var (
		tracerServiceName     = "FrontEnd"
		tracerURL             = "localhost:6831"
		tracerService, closer = tracer.New(true, tracerServiceName, tracerURL, 1)
	)

	defer func() {
		if closer == nil {
			_, _ = fmt.Fprintf(os.Stderr, "tracer closer is nil\n")
			return
		}

		if err := closer.Close(); err != nil {
			_, _ = fmt.Fprintf(os.Stdout, "closing tracer error: %s\n", err.Error())
			return
		}
	}()

	// set global tracer of this application
	opentracing.SetGlobalTracer(tracerService)

	r := mux.NewRouter()

	r.HandleFunc("/", Homepage).Methods("GET")
	r.HandleFunc("/callbacks", Callback).Methods("GET")

	// Set up a request logger, useful for debugging
	n := negroni.New()
	n.Use(negronilogrus.NewMiddleware())
	n.UseHandler(r)

	// r.Use(jaegertracing.TraceWithConfig(jaegertracing.TraceConfig{
	// 	Tracer: tracerService,
	// }))

	if err := http.ListenAndServe(":1234", r); err != nil {
		log.Fatal(err)
	}
}

func Homepage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	span, ctx := opentracing.StartSpanFromContext(ctx, "Homepage")
	defer func() {
		span.Finish()
		ctx.Done()
	}()

	//Generate random state
	b := make([]byte, 32)
	_, err := rand.Read(b)
	if err != nil {
		http.Error(w, err.Error(), http.StatusOK)
		return
	}

	state := base64.StdEncoding.EncodeToString(b)

	stateStore[state] = true

	// Will return loginURL,
	// for example: http://localhost:4444/oauth2/auth?client_id=myclient&prompt=consent&redirect_uri=http%3A%2F%2Fexample.com&response_type=code&scope=users.write+users.read+users.edit&state=XfFcFf7KL7ajzA2nBY%2F8%2FX3lVzZ6VZ0q7a8rM3kOfMM%3D
	loginURL := OAuthConf.AuthCodeURL(state)
	renderTemplate(w, "index.html", map[string]interface{}{
		"LoginURL": loginURL,
	})
}

func Callback(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	span, ctx := opentracing.StartSpanFromContext(ctx, "Callback")
	defer func() {
		span.Finish()
		ctx.Done()
	}()

	code := r.URL.Query().Get("code")
	state := r.URL.Query().Get("state")
	//scopes := r.URL.Query().Get("scope")

	if code == "" {
		http.Error(w, "Authorization code is empty", http.StatusOK)
		return
	}

	//If state is exist
	if _, exist := stateStore[state]; !exist {
		http.Error(w, "State is generated by this Client", http.StatusOK)
	}

	delete(stateStore, state)

	// Exchange code for access token
	accessToken, err := OAuthConf.Exchange(ctx, code)
	if err != nil {
		http.Error(w, err.Error(), http.StatusOK)
		return
	}

	renderTemplate(w, "after_login.html", map[string]interface{}{
		"AccessToken": accessToken,
		"IDToken":     accessToken.Extra("id_token"),
	})
}

// renderTemplate is a convenience helper for rendering templates.
func renderTemplate(w http.ResponseWriter, id string, d interface{}) bool {
	if t, err := template.New(id).ParseFiles("./templates/" + id); err != nil {
		http.Error(w, errors.Wrap(err, "Could not render template").Error(), http.StatusInternalServerError)
		return false
	} else if err := t.Execute(w, d); err != nil {
		http.Error(w, errors.Wrap(err, "Could not render template").Error(), http.StatusInternalServerError)
		return false
	}
	return true
}

// type Template struct {}

// func (t *Template) Render(w io.Writer,name string, data interface{}) error {
// 	tmpl := template.New("", &template.BinData{
// 		Asset:
// 	})
// }
